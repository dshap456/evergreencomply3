import { objectToCamel as m } from "ts-case-convert";
function q(o, v = "*") {
  if (!o)
    return v;
  let s;
  if (Array.isArray(o)) {
    const u = o, l = /* @__PURE__ */ new Map(), y = [];
    for (let f = 0; f < u.length; f++) {
      const a = u[f];
      if (a.split(".").length > 1) {
        const [p, d] = a.split(".");
        l.set(p, [...l.get(p) ?? [], d]);
      } else
        y.push(a);
    }
    for (const [f, a] of Array.from(l.entries()))
      y.push(`${f} !inner (${a.join(",")})`);
    s = y.join(",");
  } else
    s = o;
  return s;
}
async function B(o) {
  const {
    client: v,
    table: s,
    where: u,
    sort: l,
    select: y = "*",
    page: f = 1,
    limit: a = 10,
    count: p = "exact"
  } = o, d = o.camelCase ?? !1, A = q(y);
  let t = v.from(s).select(A, {
    count: p ?? "exact"
  });
  if (u)
    if (typeof u != "function") {
      const c = Object.keys(u);
      for (const b of c) {
        const n = u[b];
        if (!n)
          continue;
        const j = Object.keys(
          n ?? {}
        );
        for (const r of j) {
          const i = b;
          switch (r) {
            case "eq": {
              const e = n[r];
              if (e == null)
                continue;
              t = t.eq(i, e);
              break;
            }
            case "neq": {
              const e = n[r];
              if (e == null)
                continue;
              t = t.neq(i, e);
              break;
            }
            case "in": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.in(i, e);
              break;
            }
            case "like": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.like(i, e);
              break;
            }
            case "ilike": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.ilike(i, e);
              break;
            }
            case "gt": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.gt(i, e);
              break;
            }
            case "lt": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.lt(i, e);
              break;
            }
            case "gte": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.gte(i, e);
              break;
            }
            case "lte": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.lte(i, e);
              break;
            }
            case "textSearch": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.textSearch(i, e);
              break;
            }
            case "containedBy": {
              const e = n[r];
              if (!Array.isArray(e))
                continue;
              t = t.containedBy(i, e);
              break;
            }
            case "contains": {
              const e = n[r];
              if (!Array.isArray(e))
                continue;
              t = t.contains(i, e);
              break;
            }
            case "not": {
              const e = n[r];
              if (e === void 0)
                continue;
              for (const g in e)
                if (g in e) {
                  const S = e[g];
                  t = t.not(i, g, S);
                }
              break;
            }
            case "is": {
              const e = n[r];
              if (e === void 0)
                continue;
              t = t.is(i, e);
              break;
            }
          }
        }
      }
    } else
      typeof u == "function" && (t = u(t));
  if (!o.single) {
    if (l)
      for (const c in l)
        t = t.order(c, { ascending: l[c] === "asc" });
    if (f && a) {
      const c = (f - 1) * a, b = c + a;
      t = t.range(c, b);
    }
    a && (t = t.limit(a));
  }
  if (o.single) {
    const c = await t.maybeSingle();
    return {
      data: h(c.data ?? void 0, d),
      count: c.count ?? 0,
      error: c.error
    };
  }
  const k = await t;
  return {
    data: h(k.data ?? [], d),
    count: k.count ?? 0,
    error: k.error
  };
}
function h(o, v) {
  return v ? Array.isArray(o) ? o.map((s) => s && m(s)) : o ? m(o) : void 0 : o;
}
export {
  B as fetchDataFromSupabase
};
